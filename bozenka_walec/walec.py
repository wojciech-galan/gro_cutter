#! /usr/bin/python
# -*- coding: utf-8 -*-

import os
import argparse
import struct
import re
import numpy as np
from computations import determine_center_and_radius
from computations import squared_distance2d

AMINOACIDS = set(['GLN', 'GLY', 'GLU', 'ASP', 'SER', 'HSD', 'LYS', 'PRO', 'ASN', 'VAL', 'THR',
             'TRP', 'PHE', 'ALA', 'MET', 'LEU', 'ARG', 'TYR'])
GRO_FORMAT = "5s5s5s5s8s8s8s"
GRO_FORMAT_C = "%5d%-5s%5s%5d%8.3f%8.3f%8.3f"
FRAME_PATTERN = 'Generated by trjconv((?!Generated by trjconv).)+'
FRAME_PATTERN_PLUS = 'Generated'


class DataFrame(object):

    def __init__(self, frame_string):
        super(DataFrame, self).__init__()
        temp = frame_string.strip().split(os.linesep, 2)
        self.first_line = temp[0]
        content, self.last_line = temp[-1].rsplit(os.linesep, 1)

        def process_line(line, line_format=GRO_FORMAT): #tu już mogę te rzeczy, które są potem skipowane, opuszczać
            res_num, res_name, atom_name, atom_num, x, y, z = struct.unpack(line_format, line)
            x, y, z = map(float, (x, y, z))
            res_num, atom_num = map(int, (res_num, atom_num))
            res_name, atom_name = map(str.strip, (res_name, atom_name))
            return res_num, res_name, atom_name, atom_num, x, y, z

        self.lines = [process_line(x) for x in content.split(os.linesep)]

    def process(self, to_contain, solvent, main_in_solvent, to_skip, skip_hydrogens): #todo remove skip
        if skip_hydrogens:
            protein_atoms = [(line[4], line[5]) for line in self.lines if line[1] in AMINOACIDS and line[2].startswith('H')]
        else:
            protein_atoms = [(line[4], line[5]) for line in self.lines if line[1] in AMINOACIDS]
        x, y, r = determine_center_and_radius(np.array(protein_atoms))
        center = (x, y)
        sqared_r = r**2
        output_lines = []
        control = False
        for line in self.lines:
            if line[1] == to_contain or line[1] in AMINOACIDS:
                output_lines.append(line)
            elif line[1] == solvent :
                if line[2] == main_in_solvent:
                    if squared_distance2d(center, (line[4], line[5])) <= sqared_r:
                        output_lines.append(line)
                        control = True
                    else:
                        control = False
                elif control:
                    output_lines.append(line)
        return output_lines


def write_file(first_line, lines, last_line, outfile):
    def process_line(line, line_format=GRO_FORMAT_C):
        return line_format % line
    with open(outfile, 'a') as f:
        f.write(first_line)
        f.write(os.linesep)
        f.write(str(len(lines)))
        f.write(os.linesep)
        f.write(os.linesep.join(process_line(line) for line in lines))
        f.write(os.linesep)
        f.write(last_line)
        f.write(os.linesep)


def determine_frame_size(file_handle, read_size=10000,\
                         initial_pattern=re.compile(FRAME_PATTERN+FRAME_PATTERN_PLUS, re.DOTALL)):
    s = ''
    found = False
    while not found:
        s += file_handle.read(read_size)
        found = re.search(initial_pattern, s)
        read_size = int(read_size*2)
    read_size = found.end()
    return s, read_size


def determine_file_size(file_handle):
    curr_pos = file_handle.tell()
    file_handle.seek(0, os.SEEK_END)
    file_size = file_handle.tell()
    file_handle.seek(curr_pos)
    return file_size


def get_frames(fname, pattern=re.compile(FRAME_PATTERN+FRAME_PATTERN_PLUS, re.DOTALL),
               diff=len(FRAME_PATTERN_PLUS)):
    with open(fname) as f:
        # determine frame size
        s, read_size = determine_frame_size(f, initial_pattern=pattern)
        # determine file size
        file_size = determine_file_size(f)
        yield s[:read_size-diff]
        s = s[read_size-diff:]
        # main loop
        while f.tell() < file_size - 2: # -2 for /n in unix or /r/n in windows - the characters could be found on the
                                        # end on the file
            s += f.read(read_size)
            found = re.search(pattern, s)
            while not found and f.tell() < file_size:
                s += f.read(read_size)
                found = re.search(pattern, s)
            if f.tell() < file_size: # works for every - but the last -frame
                yield s[:found.end()-diff]
                s = s[found.end()-diff:]
                found = False
            else:
                yield s




if __name__ == '__main__':
    # todo opcja z obejrzeniem nanodysku
    parser = argparse.ArgumentParser(description='todo') # todo
    parser.add_argument('-i', help='input file')
    parser.add_argument('-o', help='output file')
    parser.add_argument('-s', '--solvent', default='TIP3', help='solvent')
    parser.add_argument('-m', '--main_atom_in_solvent', default='OH2',
                        help="coordinates of this atom are used as particle's coordinates")
    parser.add_argument('--skip_hydrogens', default=False, action='store_true',
                        help='whether to use hydrogens to determine the midddle of the circle and its radius')
    parser.add_argument('-k', '--skip', action='append', help='particles to skip')
    parser.add_argument('-c', '--contain', default='POPC',
                        help='''particles to be contained in the output file without changes.
                        AminoAcids are always rewriten to the output file''')
    args = parser.parse_args()
    # print len(open(args.i).read())
    # s = open('data/ramki.gros').read()
    # import re
    # found = re.search(FRAME_PATTERN, s, re.DOTALL)
    # print found.end()
    # raise
    import time
    t = time.time()
    if not os.path.exists(os.path.dirname(args.o)):
        os.makedirs(os.path.dirname(args.o))
    open(args.o, 'w').close() # create empty file
    for frame in get_frames(args.i):
        print '--------------------------'
        ti = time.time()
        data = DataFrame(frame)
        print time.time() -ti
        ti = time.time()
        lines = data.process(args.contain, args.solvent, args.main_atom_in_solvent, set(args.skip), args.skip_hydrogens)
        print time.time() -ti
        ti=time.time()
        write_file(data.first_line, lines, data.last_line, args.o)
        print time.time() -ti

    print time.time()-t
    raise

    print args
    import time
    t = time.time()
    data = DataFrame(open(args.i, 'rb').read())
    lines = data.process(args.contain, args.solvent, args.main_atom_in_solvent, set(args.skip), args.skip_hydrogens)
    write_file(data.first_line, lines, data.last_line, args.o)
    print time.time() - t